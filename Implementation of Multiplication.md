# Implementation of Multiplication

上课没有讲完，这里补充上这一点，即用Lesson 08中的附录C计算机编写一个乘法的程序。由于该计算机只有加法，我们需要通过累加来实现两个数相乘的操作。

比如数x乘数y，只需要**将y累加x次即可**。累加x次，不难想到**要使用循环**。我们可以先写出它的伪代码，表示处大体的逻辑，再去探究其如何进一步进行翻译，那么伪代码如下：

```pseudocode
LOAD x, y from main memory
sum := 0
for i from 1 to x
	sum := sum + y
```

最后得到的sum就是x*y的结果。



## 基础操作的机器码实现

### 1 LOAD操作

**从主存中LOAD**对应的自然是**Op-code为1**的情况，显然，假设x在地址C0处，要把它读取到寄存器0中，则机器码为**10C0**。



### 2 变量及其赋值

我们可以将变量sum和i直接使用寄存器来存储，假设用寄存器2存sum，寄存器4存i。现在要给sum一个初始值0，这个0从哪来呢，这时就要用到**Op-code为2**的情况，它可以把后两位16进制数直接当成一个数值存进前一位所标识的寄存器里。则机器码为**2200**，同理将i赋值为1的机器码为**2401**。



### 3 循环

循环需要两个要素：跳出条件和循环体

跳出条件为i==x+1，假设x+1的值已经存在了0号寄存器，跳出地址为B4，i的值在寄存器4中，那么对应的机器码就是**B4B4**



## 最终的机器码

假设x在地址为C0处，y在地址为C1处：

```
Addr	Code
A0		10C0 # 从C0取出x的值存到0号寄存器（以下用$0表示）
A2		11C1 # 从C1取出y的值存到1号寄存器（以下用$1表示）
A4		2200 # 将2号寄存器（sum）赋值为0（以下用$2表示）
A6		2301 # 将3号寄存器（用于给x+1和i+1时使用）赋值为1（以下用$3表示）
A8		5003 # $0 := $0 + $3 (x := x + 1)
AA		2401 # 将4号寄存器（i）赋值为1（以下用$4表示）
AC		B4B4 # 如果$4=$0（i=x），则跳转到程序地址B4处
AE		5221 # $2 = $2 + $1 (sum := sum + y)
B0		5443 # $4 = $4 + $3 (i = i + 1)
B2		B0AC # 强制跳转回循环的判断条件处
B4		32C2 # 将结果存回主存中
B6		C000 # 停机
```

最后，结果被存回主存的地址为C2处。